import{f as w,Z as y,c as p,b as z}from"./index-BkRml8Bg.js";var b=Object.defineProperty,A=(u,t,s)=>t in u?b(u,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):u[t]=s,i=(u,t,s)=>A(u,typeof t!="symbol"?t+"":t,s);class P{constructor(t,s,e,a){i(this,"processNoise"),i(this,"measurementNoise"),i(this,"estimate"),i(this,"estimateError"),this.processNoise=t,this.measurementNoise=s,this.estimate=e,this.estimateError=a}update(t){const s=this.estimate,e=this.estimateError+this.processNoise,a=e/(e+this.measurementNoise);return this.estimate=s+a*(t-s),this.estimateError=(1-a)*e,this.estimate}getEstimate(){return this.estimate}}class E{constructor(t){i(this,"config",{earlyEstimation:!1,minDuration:10,minConfidence:.6,debug:!1}),i(this,"estimation_",null),i(this,"signalBuffer",[]),i(this,"timestamps",[]),i(this,"maxBufferSize",512),i(this,"modelSession",null),i(this,"welchSession",null),i(this,"hrSession",null),i(this,"state",{}),i(this,"lastTimestamp",null),i(this,"lambda",1),i(this,"welchArray",[]),i(this,"welchCount",0),i(this,"welchBufferSize",300),i(this,"kfOutput",null),i(this,"kfHr",null),i(this,"meanHRErr",.04),i(this,"isInitialized",!1),i(this,"isInitializing",!1),i(this,"modelPath","/models/me-rppg/model.onnx"),i(this,"statePath","/models/me-rppg/state.json"),i(this,"welchPath","/models/me-rppg/welch_psd.onnx"),i(this,"hrPath","/models/me-rppg/get_hr.onnx"),t&&(this.configure(t),t.modelPath&&(this.modelPath=t.modelPath),t.statePath&&(this.statePath=t.statePath),t.welchPath&&(this.welchPath=t.welchPath),t.hrPath&&(this.hrPath=t.hrPath),t.lambda!==void 0&&(this.lambda=t.lambda)),this.initializeModels()}log(t,...s){this.config.debug&&console.log(`[MeRppgRealtimeEstimator] ${t}`,...s)}async initializeModels(){if(!(this.isInitializing||this.isInitialized)){this.isInitializing=!0;try{w.wasm.wasmPaths="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.23.2/dist/",w.wasm.numThreads=1,w.wasm.simd=!0,this.log("Loading ONNX models..."),this.modelSession=await y.create(this.modelPath,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),this.log("Main model loaded");const t=await(await fetch(this.statePath)).json();for(const[s,e]of Object.entries(t)){const a=this.shapeOf(e),r=new Float32Array(this.flattenArray(e));this.state[s]=new p("float32",r,a)}this.log("Initial state loaded"),this.welchSession=await y.create(this.welchPath,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),this.log("Welch PSD model loaded"),this.hrSession=await y.create(this.hrPath,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),this.log("HR extraction model loaded"),this.isInitialized=!0,this.log("All models initialized successfully")}catch(t){console.error("Failed to initialize ONNX models:",t),this.isInitialized=!1}finally{this.isInitializing=!1}}}shapeOf(t){const s=[];let e=t;for(;Array.isArray(e);)s.push(e.length),e=e[0];return s}flattenArray(t){return Array.isArray(t)?t.reduce((s,e)=>s.concat(this.flattenArray(e)),[]):[t]}get estimation(){return this.estimation_}get signalData(){return this.signalBuffer.length===0?null:{values:[...this.signalBuffer],timestamps:[...this.timestamps],sampleRate:this.getSampleRate()}}configure(t){t&&(this.config={...this.config,...t})}processFrame(t,s,e,a){s!==z.Idle&&(!a||!a.face||this.processFrameAsync(t,a.face))}async processFrameAsync(t,s){if(!(!this.isInitialized||!this.modelSession))try{const e=await this.extractFaceImage(s);if(!e)return;const a=Date.now()/1e3,r=new p("float32",e,[1,1,36,36,3]),l=this.lastTimestamp?Math.max((a-this.lastTimestamp)/this.lambda,1/90):1/30,o=new p("float32",[l],[]);this.lastTimestamp=a;const n={};n[this.modelSession.inputNames[0]]=r;for(const[c,g]of Object.entries(this.state))n[c]=g;n[this.modelSession.inputNames[37]]=o;const h=await this.modelSession.run(n),m=h[this.modelSession.outputNames[0]].data[0];for(let c=1;c<this.modelSession.outputNames.length;c++)this.state[this.modelSession.inputNames[c]]=h[this.modelSession.outputNames[c]];this.kfOutput?this.kfOutput.update(m):this.kfOutput=new P(1,.5,m,1);const d=this.kfOutput.getEstimate();this.signalBuffer.push(d),this.timestamps.push(Date.now()),this.signalBuffer.length>this.maxBufferSize&&(this.signalBuffer.shift(),this.timestamps.shift()),this.welchArray.push(d),this.welchArray.length>this.welchBufferSize&&this.welchArray.shift(),this.welchCount++,this.welchCount>=30&&this.welchArray.length>=this.welchBufferSize&&(await this.processWelch(),this.welchCount=0)}catch(e){console.warn("Failed to process frame:",e)}}async extractFaceImage(t){try{const s=await t.imageData;if(!s)return null;const e=document.createElement("canvas");e.width=36,e.height=36;const a=e.getContext("2d");if(!a)return null;const r=document.createElement("canvas");r.width=s.width,r.height=s.height;const l=r.getContext("2d");if(!l)return null;l.putImageData(s,0,0),a.drawImage(r,0,0,s.width,s.height,0,0,36,36);const o=a.getImageData(0,0,36,36).data,n=new Float32Array(1296*3);for(let h=0;h<o.length;h+=4){const m=h/4;n[m*3]=o[h]/255,n[m*3+1]=o[h+1]/255,n[m*3+2]=o[h+2]/255}return n}catch(s){return console.warn("Failed to extract face image:",s),null}}async processWelch(){if(!(!this.welchSession||!this.hrSession))try{const t=new Float32Array(this.welchArray),s=new p("float32",t,[1,1,t.length]),e=await this.welchSession.run({input:s}),a=e.freqs,r=e.psd;let l=(await this.hrSession.run({freqs:a,psd:r})).hr.data[0];if(this.timestamps.length>300){const m=this.timestamps.slice(-301);let d=0,c=0;for(let f=1;f<m.length;f++){const S=(m[f]-m[f-1])/1e3;S<=.5&&(d+=S,c++)}const g=d>0?c/d:30;l=l/30*g}this.kfHr?this.kfHr.update(l):this.kfHr=new P(1,2,l,1);const o=this.kfHr.getEstimate();this.meanHRErr=.8*this.meanHRErr+.2*Math.abs(o-l)/l;const n=this.meanHRErr<.02,h=Math.max(0,Math.min(1,1-this.meanHRErr*10));this.estimation_={heartRate:o,confidence:h,isStable:n,signalQuality:h*100},this.log(`Estimated HR: ${o.toFixed(1)} BPM, Confidence: ${h.toFixed(2)}, Stable: ${n}`)}catch(t){console.warn("Failed to process Welch:",t)}}getSampleRate(){if(this.timestamps.length<2)return 30;const t=this.timestamps[this.timestamps.length-1]-this.timestamps[0];return(this.timestamps.length-1)*1e3/t}updateWithServerResult(t,s,e){this.estimation_={heartRate:Math.round(t),confidence:1,isStable:!0,snr:s,signalQuality:e}}reset(){this.estimation_=null,this.signalBuffer=[],this.timestamps=[],this.welchArray=[],this.welchCount=0,this.kfOutput=null,this.kfHr=null,this.lastTimestamp=null,this.meanHRErr=.04,this.isInitialized&&this.initializeModels()}setLambda(t){this.lambda=t}}export{E as MeRppgRealtimeEstimator};

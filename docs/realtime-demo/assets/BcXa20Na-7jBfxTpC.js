import{J as o,x as n,d as c}from"./index-BaOtp5zW.js";var m=Object.defineProperty,d=(h,t,e)=>t in h?m(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e,s=(h,t,e)=>d(h,typeof t!="symbol"?t+"":t,e);class f{constructor(t){s(this,"config",{earlyEstimation:!1,minDuration:10,minConfidence:.6,debug:!1}),s(this,"estimation_",null),s(this,"signalBuffer",[]),s(this,"timestamps",[]),s(this,"maxBufferSize",512),s(this,"welchArray",[]),s(this,"welchCount",0),s(this,"welchBufferSize",300),s(this,"isInitialized",!1),s(this,"isInitializing",!1),s(this,"modelPath","models/me-rppg/model.onnx"),s(this,"statePath","models/me-rppg/state.json"),s(this,"welchPath","models/me-rppg/welch_psd.onnx"),s(this,"hrPath","models/me-rppg/get_hr.onnx"),s(this,"lambda",1),s(this,"workerFactory",()=>new Worker(new URL("/sdk-live-demo/realtime-demo/assets/DYGX-n6P-DcQWTRQD.js",import.meta.url),{type:"module"})),s(this,"workerPool"),t&&(this.configure(t),t.modelPath&&(this.modelPath=t.modelPath),t.statePath&&(this.statePath=t.statePath),t.welchPath&&(this.welchPath=t.welchPath),t.hrPath&&(this.hrPath=t.hrPath),t.lambda!==void 0&&(this.lambda=t.lambda)),this.workerPool=o(this.workerFactory,c,"MeRppgWorker",3e4,1),this.initializeModels()}log(t,...e){this.config.debug&&console.log(`[MeRppgRealtimeEstimator] ${t}`,...e)}async initializeModels(){if(!(this.isInitializing||this.isInitialized)){this.isInitializing=!0;try{this.log("Initializing ONNX models in worker...");const t=new URL(document.baseURI),e=a=>new URL(a,t).href,i={type:"init",modelPath:e(this.modelPath),statePath:e(this.statePath),welchPath:e(this.welchPath),hrPath:e(this.hrPath),lambda:this.lambda};this.isInitialized=!0,this.log("Initialization request sent to worker"),this.workerPool.callWorker(i).catch(a=>{console.error("Failed to initialize worker:",a),this.isInitialized=!1})}catch(t){console.error("Failed to initialize ONNX models:",t),this.isInitialized=!1}finally{this.isInitializing=!1}}}get estimation(){return this.estimation_}get signalData(){return this.signalBuffer.length===0?null:{values:[...this.signalBuffer],timestamps:[...this.timestamps],sampleRate:this.getSampleRate()}}configure(t){t&&(this.config={...this.config,...t})}processFrame(t,e,i,a){e!==n.Idle&&(!a||!a.face||this.processFrameAsync(t,a.face))}async processFrameAsync(t,e){if(this.isInitialized)try{const i=await e.imageData;if(!i)return;const a=Date.now()/1e3,l={type:"process",imageData:i,timestamp:a};this.workerPool.callWorker(l,{transfer:[]}).then(r=>{r.type==="processed"&&r.bvpValue!==void 0?(this.signalBuffer.push(r.bvpValue),this.timestamps.push(Date.now()),this.signalBuffer.length>this.maxBufferSize&&(this.signalBuffer.shift(),this.timestamps.shift()),this.welchArray.push(r.bvpValue),this.welchArray.length>this.welchBufferSize&&this.welchArray.shift(),this.welchCount++,this.welchCount>=30&&this.welchArray.length>=this.welchBufferSize&&(this.processWelch(),this.welchCount=0)):r.type==="error"&&console.warn("Worker error:",r.error)}).catch(r=>{this.config.debug&&console.warn("Failed to process frame in worker:",r)})}catch(i){console.warn("Failed to process frame:",i)}}async processWelch(){var t;if(this.isInitialized)try{const e={type:"welch",welchArray:[...this.welchArray],timestamps:[...this.timestamps]},i=await this.workerPool.callWorker(e);i.type==="welch"&&i.heartRate!==void 0?(this.estimation_={heartRate:i.heartRate,confidence:i.confidence||0,isStable:i.isStable||!1,signalQuality:i.signalQuality||0},this.log(`Estimated HR: ${i.heartRate.toFixed(1)} BPM, Confidence: ${(t=i.confidence)==null?void 0:t.toFixed(2)}, Stable: ${i.isStable}`)):i.type==="error"&&console.warn("Worker error during Welch processing:",i.error)}catch(e){console.warn("Failed to process Welch:",e)}}getSampleRate(){if(this.timestamps.length<2)return 30;const t=this.timestamps[this.timestamps.length-1]-this.timestamps[0];return(this.timestamps.length-1)*1e3/t}updateWithServerResult(t,e,i){this.estimation_={heartRate:Math.round(t),confidence:1,isStable:!0,snr:e,signalQuality:i}}reset(){if(this.estimation_=null,this.signalBuffer=[],this.timestamps=[],this.welchArray=[],this.welchCount=0,this.isInitialized){const t={type:"reset",statePath:this.statePath};this.workerPool.callWorker(t).catch(e=>{console.warn("Failed to reset worker:",e)})}}setLambda(t){this.lambda=t}dispose(){this.workerPool.terminateAll()}}export{f as MeRppgRealtimeEstimator};

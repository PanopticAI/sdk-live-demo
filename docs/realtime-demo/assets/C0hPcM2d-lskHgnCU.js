import{x as F}from"./index-BaOtp5zW.js";var $=Object.defineProperty,S=(y,t,e)=>t in y?$(y,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):y[t]=e,i=(y,t,e)=>S(y,typeof t!="symbol"?t+"":t,e);class B{constructor(t){i(this,"config",{earlyEstimation:!1,minDuration:10,minConfidence:.6,debug:!1}),i(this,"estimation_",null),i(this,"signalBuffer",[]),i(this,"timestamps",[]),i(this,"maxBufferSize",300),i(this,"minSamplesForEstimation",30),i(this,"currentPulseRate",0),i(this,"onPulseRateUpdate"),i(this,"heartRateHistory",[]),i(this,"maxHistorySize",10),i(this,"defaultFps",30),i(this,"earlyGuessThreshold",15),i(this,"earlyResultSampleThreshold",90),i(this,"earlyResultMaxHeartRate",150),i(this,"earlyResultMinHeartRate",50),i(this,"stableResultMaxHeartRate",130),i(this,"stableResultMinHeartRate",60),i(this,"minConfidenceForDisplay",1e-4),i(this,"effectiveMinConfidence",.3),i(this,"earlyResultMinHistoryLength",2),i(this,"muchEarlierTriggerThreshold",10),i(this,"minSignalLengthForDetrending",3),i(this,"detrendingWindowSize",50),i(this,"detrendingAmplification",10),i(this,"lowPassWindowSize",5),i(this,"maxAutocorrelationLags",150),i(this,"minAutocorrelationLength",10),i(this,"minBpmForPeakFinding",50),i(this,"maxBpmForPeakFinding",150),i(this,"minLagForPeakFinding",5),i(this,"minSignalLengthForMetrics",10),i(this,"expectedPpgAmplitude",20),i(this,"snrNormalizationFactor",5),i(this,"consistencyScoreFactor",2),i(this,"minSignalLengthForTrendStability",5),i(this,"confidenceWeights",{amplitude:.3,snr:.4,consistency:.2,stability:.1}),i(this,"signalQualityWeights",{amplitude:.4,consistency:.4,stability:.2}),i(this,"earlyGuessMinHeartRate",50),i(this,"earlyGuessMaxHeartRate",150),i(this,"earlyGuessMinLag",5),i(this,"earlyGuessConfidenceBoost",.3),i(this,"earlyGuessMinConfidence",.001),i(this,"stabilityCheckMinHistoryLength",5),i(this,"stabilityThresholdBpm",10),i(this,"defaultTimeIntervalMs",33),t&&this.configure(t)}log(t,...e){this.config.debug&&console.log(`[Realtime Estimater] ${t}`,...e)}get estimation(){return this.estimation_}get signalData(){return this.signalBuffer.length===0?null:{values:[...this.signalBuffer],timestamps:[...this.timestamps],sampleRate:this.timestamps.length>1?1e3/((this.timestamps[this.timestamps.length-1]-this.timestamps[0])/(this.timestamps.length-1)):this.defaultFps}}configure(t){t&&(this.config={...this.config,...t})}processFrame(t,e,s,a){if(this.log(`processFrame called, stage=${e}, hasROI=${!!(a!=null&&a.face)}`),e===F.Idle){this.log(`Skipping - idle stage (${e})`);return}if(!a||!a.face){this.log("Skipping - no ROI data");return}this.log(`Processing frame with ROI in stage ${e}`),this.processFrameAsync(t,a.face)}async processFrameAsync(t,e){const s=await this.extractRealPPGSignal(t,e);s!==null?(this.signalBuffer.push(s),this.timestamps.push(Date.now()),this.log(`Added to buffer - intensity: ${s.toFixed(2)}, buffer size: ${this.signalBuffer.length}`),this.signalBuffer.length>this.maxBufferSize&&(this.signalBuffer.shift(),this.timestamps.shift()),this.signalBuffer.length>=this.minSamplesForEstimation?(this.log(`Processing signal - ${this.signalBuffer.length} samples`),this.processSignal()):this.signalBuffer.length>=this.earlyGuessThreshold&&!this.estimation_?(this.log(`Attempting early guess - ${this.signalBuffer.length} samples`),this.processSignal()):this.log(`Not enough samples yet (${this.signalBuffer.length}/${this.minSamplesForEstimation})`)):this.log("Failed to extract intensity")}async extractRealPPGSignal(t,e){try{this.log("Extracting PPG signal from ROI");const s=await e.imageData;if(!s)return this.log("No imageData available"),null;const a=s.data;this.log(`ImageData length: ${a.length}`);let g=0,n=0;for(let o=0;o<a.length;o+=4)g+=a[o+1],n++;const l=n>0?g/n:null;return this.log(`Extracted intensity: ${l}`),l}catch(s){return console.warn("Failed to extract PPG signal:",s),null}}processSignal(){var t;if(this.signalBuffer.length<this.minSamplesForEstimation){this.log(`Not enough samples (${this.signalBuffer.length}/${this.minSamplesForEstimation})`);return}try{const e=this.bandpassFilter(this.signalBuffer),s=this.calculateAutocorrelation(e);this.log(`Raw signal range: [${Math.min(...this.signalBuffer).toFixed(2)}-${Math.max(...this.signalBuffer).toFixed(2)}]`),this.log(`Filtered signal range: [${Math.min(...e).toFixed(2)}-${Math.max(...e).toFixed(2)}]`),this.log(`Autocorr range: [${Math.min(...s).toFixed(4)}-${Math.max(...s).toFixed(4)}]`);const a=this.findDominantPeak(s);if(this.log(`signalLength=${this.signalBuffer.length}, filteredLength=${e.length}, autocorrLength=${s.length}, peakIndex=${a}`),a>0){const g=1e3/this.getAverageTimeInterval(),n=g/a,l=n*60;this.log(`sampleRate=${g.toFixed(1)}, peakIndex=${a}, frequency=${n.toFixed(2)}, heartRate=${l.toFixed(1)}`);const o=this.signalBuffer.length<this.earlyResultSampleThreshold,r=o?this.earlyResultMaxHeartRate:this.stableResultMaxHeartRate,h=o?this.earlyResultMinHeartRate:this.stableResultMinHeartRate;if(l>=h&&l<=r){const c=Math.round(l),m=this.calculateSignalMetrics(e),u=m.confidence,f=u>(this.config.minConfidence||.3)&&this.signalBuffer.length>=this.minSamplesForEstimation&&this.checkHeartRateStability();this.log(`confidence=${(u*100).toFixed(1)}%, snr=${m.snr.toFixed(2)}, signalQuality=${m.signalQuality.toFixed(1)}, isStable=${f}, signalLength=${this.signalBuffer.length}`);const p=this.minConfidenceForDisplay,d=this.signalBuffer.length<this.earlyResultSampleThreshold,M=d?this.minConfidenceForDisplay:this.config.minConfidence||this.effectiveMinConfidence;if(u>=p){const R=d?this.heartRateHistory.length>=this.earlyResultMinHistoryLength:this.checkHeartRateStability(),x=u>M&&R;(!this.estimation_||this.estimation_.heartRate!==c||d)&&(this.estimation_={heartRate:c,confidence:u,isStable:x,snr:m.snr,signalQuality:m.signalQuality},this.heartRateHistory.push(c),this.heartRateHistory.length>this.maxHistorySize&&this.heartRateHistory.shift(),this.currentPulseRate=c,(t=this.onPulseRateUpdate)==null||t.call(this,this.currentPulseRate),this.log(`Updated estimation - HR: ${c} BPM, Confidence: ${(u*100).toFixed(1)}%, Early: ${d}`))}else this.signalBuffer.length>=this.muchEarlierTriggerThreshold?this.provideEarlyGuess(e,s):this.log(`Confidence too low (${(u*100).toFixed(1)}%) for display`)}}}catch(e){console.warn("Failed to process PPG signal:",e)}}bandpassFilter(t){const e=[];if(t.length<this.minSignalLengthForDetrending)return e;const s=this.detrendingWindowSize;for(let n=0;n<t.length;n++){const l=Math.max(0,n-s),o=Math.min(t.length,n+s+1),r=t.slice(l,o),h=r.reduce((m,u)=>m+u,0)/r.length,c=(t[n]-h)*this.detrendingAmplification;e.push(c)}const a=[],g=this.lowPassWindowSize;for(let n=0;n<e.length;n++){const l=Math.max(0,n-g),o=Math.min(e.length,n+g+1),r=e.slice(l,o);a.push(r.reduce((h,c)=>h+c,0)/r.length)}return a}calculateAutocorrelation(t){const e=[],s=t.length,a=t.reduce((n,l)=>n+l,0)/s,g=t.reduce((n,l)=>n+Math.pow(l-a,2),0)/s;for(let n=0;n<Math.min(s-1,this.maxAutocorrelationLags);n++){let l=0,o=0;for(let h=0;h<s-n;h++)l+=(t[h]-a)*(t[h+n]-a),o++;const r=o>0?l/(o*g+1e-10):0;e.push(r)}return e}findDominantPeak(t){if(t.length<this.minAutocorrelationLength)return this.log(`Autocorr too short (${t.length})`),0;const e=1e3/this.getAverageTimeInterval(),s=Math.floor(e/(this.maxBpmForPeakFinding/60)),a=Math.floor(e/(this.minBpmForPeakFinding/60));this.log(`sampleRate=${e.toFixed(1)}, minPeriod=${s}, maxPeriod=${a}, autocorrRange=[${s+1}-${Math.min(a,t.length-1)}]`);const g=s+1,n=Math.min(a,t.length-1),l=t.slice(g,n+1);this.log(`Autocorr values [${g}-${n}]:`,l.map((h,c)=>`${g+c}:${h.toFixed(4)}`).join(", "));let o=0,r=0;for(let h=Math.max(this.minLagForPeakFinding,s);h<Math.min(a,t.length);h++)t[h]>o&&(o=t[h],r=h);return r>0?(this.log(`Found best peak at index ${r}, value=${o.toFixed(4)}`),r):(this.log("No acceptable peaks found"),0)}calculateSignalMetrics(t){if(t.length<this.minSignalLengthForMetrics)return{confidence:0,snr:0,signalQuality:0};const e=Math.max(...t)-Math.min(...t),s=t.reduce((u,f)=>u+f,0)/t.length,a=t.reduce((u,f)=>u+Math.pow(f-s,2),0)/t.length,g=Math.sqrt(a),n=Math.min(e/this.expectedPpgAmplitude,1),l=e/(g+.001),o=Math.min(l/this.snrNormalizationFactor,1),r=Math.max(0,1-g/(e+.001)*this.consistencyScoreFactor);let h=0;if(t.length>this.minSignalLengthForTrendStability){const u=t.slice(0,Math.floor(t.length/2)),f=t.slice(Math.floor(t.length/2)),p=Math.max(...u)-Math.min(...u),d=Math.max(...f)-Math.min(...f),M=(p+d)/2;h=1-Math.abs(p-d)/(M+.001)}const c=n*this.confidenceWeights.amplitude+o*this.confidenceWeights.snr+r*this.confidenceWeights.consistency+h*this.confidenceWeights.stability,m=n*this.signalQualityWeights.amplitude+r*this.signalQualityWeights.consistency+h*this.signalQualityWeights.stability;return{confidence:Math.max(0,Math.min(1,c)),snr:Math.max(0,l),signalQuality:Math.max(0,Math.min(100,m*100))}}provideEarlyGuess(t,e){var s;const a=1e3/this.getAverageTimeInterval(),g=Math.floor(a/(this.earlyGuessMaxHeartRate/60)),n=Math.floor(a/(this.earlyGuessMinHeartRate/60));let l=0,o=0;for(let r=Math.max(this.earlyGuessMinLag,g);r<Math.min(n,e.length);r++)e[r]>l&&(l=e[r],o=r);if(o>0){const r=a/o,h=Math.round(r*60);if(h>=this.earlyGuessMinHeartRate&&h<=this.earlyGuessMaxHeartRate){const c=this.calculateSignalMetrics(t),m=Math.max(c.confidence*this.earlyGuessConfidenceBoost,this.earlyGuessMinConfidence);(!this.estimation_||!0)&&(this.estimation_={heartRate:h,confidence:m,isStable:!1,snr:c.snr,signalQuality:c.signalQuality},this.currentPulseRate=h,(s=this.onPulseRateUpdate)==null||s.call(this,this.currentPulseRate),this.log(`Early guess - HR: ${h} BPM, Confidence: ${(m*100).toFixed(1)}% (BEST GUESS)`))}}}checkHeartRateStability(){if(this.heartRateHistory.length<this.stabilityCheckMinHistoryLength)return!1;const t=this.heartRateHistory.reduce((s,a)=>s+a,0)/this.heartRateHistory.length,e=this.heartRateHistory.reduce((s,a)=>s+Math.pow(a-t,2),0)/this.heartRateHistory.length;return Math.sqrt(e)<this.stabilityThresholdBpm}updateWithServerResult(t,e,s){var a;this.log(`Updating estimation with server result: ${t} BPM, SNR: ${e}, Signal Quality: ${s}`),this.estimation_={heartRate:Math.round(t),confidence:1,isStable:!0,snr:e,signalQuality:s},this.currentPulseRate=Math.round(t),(a=this.onPulseRateUpdate)==null||a.call(this,this.currentPulseRate)}reset(){this.estimation_=null,this.signalBuffer=[],this.timestamps=[],this.currentPulseRate=0,this.heartRateHistory=[]}getAverageTimeInterval(){if(this.timestamps.length<2)return this.defaultTimeIntervalMs;let t=0;for(let e=1;e<this.timestamps.length;e++)t+=this.timestamps[e]-this.timestamps[e-1];return t/(this.timestamps.length-1)}}export{B as DefaultRealtimeEstimator};
